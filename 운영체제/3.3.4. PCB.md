# PCB
- Process Control Block
- 프로세스에 대한 메타데이터를 저장한 데이터로 주기억장치에 저장됨
- 프로세스가 생성되면 운영체제는 해당 PCB를 생성함
- 프로세스의 중요한 정보를 포함하고 있으므로 일반 사용자가 접근하지 못하도록 커널 스택의 가장 앞부분에서 관리

## PCB 구조
|구분|구성요소|설명|
|---|-------|---|
|프로세스 정보|프로세스 ID|개별 프로세스를 식별할 수 있는 고유값, 해당 프로세스의 자식ID도 포함 |
|프로세스 정보|프로세스 스케줄링 상태|프로세스의 생성, 준비, 대기, 실행, 중단 등을 표현하는 현재 상태 |
|프로세스 정보|프로레스 우선순위|사용자가 할당하거나 운영 체제 자체에서 할당|
|프로세스 정보|프로레스 어카운트|프로세스에 사용된 CPU 시간, 사용량, 연결 시간 등의 자원 정도|
|프로세스 정보|프로그램 카운터|프로세스에서 실행해야 할 다음 명령어 주소에 대한 포인터|
|프로세스 정보|프로레스 권한|컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보|
|환경 정보|CPU 레지스터|프로세스를 실행하기 위해 저장해야할 레지스터에 대한 정보, 문맥교환의 인터럽트가 발생하는 경우, 임시정보를 저장|
|환경 정보|CPU 스케줄링 정보|CPU 스케줄러에 의해 중단된 시간 등에 대한 정보|
|환경 정보|PCB pointer|프로세스, 자원, 메모리 등 상위 프로세스가 생성하는 모든 하위 프로세스를 쉽게 찾을 수 있도록 계층구조 관리|
|환경 정보|Event Information|특정 프로세스가 블록상태인 경우, 이벤트 정보를 관리, 이벤튿와 필드값이 일치하면 블록에서 준비로 변경|
|환경 정보|List of Opne Files|프로그램이 사용하고 있는 파일 목록 관리, 프로그램 종료시 열린 파일을 확인하는 역할|
|환경 정보|I/O 상태 정보|프로세스에 할당된 I/O 디바이스 목록|

## 컨텍스트 스위칭(문맥 교환)
![image](https://user-images.githubusercontent.com/90097723/194819886-948bc0e0-b27b-4571-9cf1-0224d11bfc10.png)
- PCB를 교환하는 과정
- CPU가 어떤 프로세스를 실행하고 있는 상태에서 인터럽트에 의해 다음 우선 순위를 가진 프로세스가 실행되어야 할 때 기존의 프로세스 정보들은 PCB에 저장하고 다음 프로세스의 정보를 PCB에서 가져와 교체하는 작업
- 컨텍스트 스위칭이 발생하는 상황
  1. I/O interrupt
  2. CPU 사용시간 만료
  3. 자식 프로세스 Fork (새 프로세스를 만드는 시스템 호출)
  4. 인터럽트 처리 대기
- 컨텍스트 스위칭을 하는 주체는 스케줄러

### 컨텍스트 스위칭에 사용되는 비용
#### 유휴 시간
- 컨텍스트 스위칭이 일어날 때 프로세스가 멈추고 다시 작동하기 전까지 대기하는 유휴 시간이 발생함.
#### 캐시미스
- 캐시미스 : 캐시 메모리에 해당 데이터가 없어서 DRAM에서 가져와야 하는 경우
- 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생겨 캐시클리어 과정을 겪고 캐시미스가 발생됨.
- 컨텍스트 스위칭이 너무 잦으면 오버헤드가 발생하여(비용이 높아)성능이 떨어진다

### 스레드에서의 컨텍스트 스위칭
- 스레드는 스택 영역을 제외한 모든 메모리를 공유하므로 컨텍스트 스위칭의 비용이 더 적고 시간도 적게 걸림

### 참고자료
- [컨택스트 스위칭(Context Switching)](https://www.crocus.co.kr/1364)
- [PCB_youtube](https://www.youtube.com/watch?v=v-bOvvSJiLA)
- [프로세스의 문맥](https://data-engineer.tistory.com/47)
- [PCB와 Context Switchi](https://m.blog.naver.com/adamdoha/222019884898)
